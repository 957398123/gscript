// 天劫挂机模块

// 巡逻挂机状态 -2-定时挂机 -1-定点挂机 0-初始状态 1-更新下一位置 2-寻径中 4-功能代码
var hook_status = 0;

// 挂机地点列表，如果当前挂机地图设置了一系列挂机坐标，会打完怪物后移动到下一个挂机点
var hook_pos = null;

// 当前挂机点位置
var hook_offset = 0;

// 下一个点步进方向 0是正向 1是逆向
var hook_direction = 0;

// 当前挂机地图名称
var hook_map_name = null;

// 是否要查找巡逻挂机地图
var need_find_map = false;

// 当前挂机寻地图路径索引
var hook_map_path = null;

// 当前挂机寻地图名称索引
var hook_map_path2 = null;

// 当前挂机寻路地图索引
var hook_map_index = -1;

// 等待状态 0-未等待 1-等待中 2-等待完成
var hook_is_wait = 0;

// 采集状态 0-未等待 1-等待中
var hook_collection_status = 0;

// 等待时间计数（单位秒）
var hook_wait_time = 0;

// 退出角色后等待登录时间
var hook_login_time = -1;

// 要登录的角色名称
var hook_login_name = "";

// 等待释放技能 0-初始状态 1-等待释放技能 2-释放技能中 3-技能释放完毕
var hook_skill_wait = 0;

// 定点挂机剩余时间
var hook_hang_time = 0;

// 过图等待队员时间
var hook_wait_team = 5;

// 组队挂机函数实现
function teamBattle(){
    // 判断当前玩家是不是队长，如果是队长，根据当前挂机模式（定点或者巡逻）进行挂机，但是也会根据职业监控队员状态
    // 如果是队员，不进行默认挂机操作，而是跟随队长，并且优先攻击队长打的怪，如果队长打的怪死了，就优先攻击正在打其它队员的怪
    // 在根据身份进行挂机操作前。优先检测队员状态，优先处理队长
    if(player.isTeamLeader){  // 如果自己是队长
        // 等待队员一定时间后，开始挂机
        if(hook_wait_team <= 0){
            patrolBattle();
        }
    }else{
        // 首先检测是否能看到队长，不能进行等待
        var leader = gameEnv.getTeamLeader();
        // 如果能看到队长，设置跟随
        if(player.isAroundObj(leader)){
            // 设置跟随队长
            player.setFollowObj(leader);
            // 检测是否跟随到目标（如果开了移动施法，不受此限制）
            if(player.isFollowObj || GAME_VARS.isMoveCast){
                // 监控队伍成员状态
                monitorTeamStatus();
                // 可以开始挂机了
                battleTeam();
            }
        }
    }
}

// 巡逻挂机实现函数
function patrolBattle() {
    // 玩家死亡了，先复活
    if (player.isDead) {
        gameEnv.keyPressed(NUM_11);
    } {
        // 检测角色是否需要
        if (hook_status != -1) {
            drugStatus();
        }
        // 只有在游戏中才进行更新
        if (gameEnv.status == 5 && hook_map_name != null && hook_map_name != gameEnv.mapName) {
            // 检测当前是否已经找出寻路路径
            if (hook_map_path == null) {
                hook_map_path = gameEnv.aStar2WorldByIndex(gameEnv.mapName, hook_map_name);
                hook_map_path2 = gameEnv.aStar2WorldByString(gameEnv.mapName, hook_map_name);
                // 为空，结束挂机
                if (hook_map_path == null) {
                    // 如果当前地图没有巡逻挂机,取消挂机
                    if(gameEnv.getMapLoopData() != null){
                        printMessage(":未找到前往下一地图路径，当前地图存在巡逻挂机数据，开始挂机！");
                        // 这里必须设置当前地图为挂机地图
                        hook_map_name = gameEnv.mapName;
                        hook_status = 0;
                    }else{
                        printMessage(":未找到前往挂机图路径，取消挂机！");
                        setIsHangUp(false);
                    }
                } else {
                    printMessage(":检测到当前不在挂机图，开始寻路径！");
                    hook_map_index = 0;
                }
            } else if (!player.isFindPath()) {  // 设置寻路位置
                // 查找当前地图的index
                for (var i = 0; i < hook_map_path2.length; ++i) {
                    if (hook_map_path2[i] == gameEnv.mapName) {
                        hook_map_index = i;
                        break;
                    }
                }
                if (hook_map_index != -1) {
                    var map1 = hook_map_path[hook_map_index];
                    var map2 = hook_map_path[hook_map_index + 1];
                    var pos = gameEnv.getCurrMap2MapPos(map1, map2);
                    if (pos != null) {
                        // 设置寻路坐标
                        printMessage(":正在前往下一地图：" + hook_map_path2[hook_map_index + 1]);
                        player.setAimColRow(pos[0], pos[1]);
                    } else if(gameEnv.getMapLoopData() != null){
                        printMessage(":未找到前往下一地图路径，当前地图存在巡逻挂机数据，开始挂机！");
                        // 这里必须设置当前地图为挂机地图
                        hook_map_name = gameEnv.mapName;
                        hook_status = 0;
                    } else {
                        printMessage(":未找到前往下一地图路径，取消挂机！");
                        // 取消挂机
                        setIsHangUp(false);
                    }
                } else {
                    printMessage(":未找到前往挂机图路径，取消挂机！");
                    // 取消挂机
                    setIsHangUp(false);
                }
            }
        } else {
            if (hook_status == 0) {
                // 初始状态，检测当前地图是否有挂机坐标
                // 更新挂机地图数据
                need_find_map = false;
                hook_map_name = gameEnv.mapName;
                hook_pos = gameEnv.getMapLoopData();
                if (hook_pos != null) {
                    hook_status = 1;
                    // 根据方向设置offset
                    if (hook_direction == 0) {  // 正向或者默认值
                        // 从第2个点开始
                        if (hook_pos.length > 1) {
                            hook_offset = 1;
                        } else {
                            hook_offset = 0;
                        }
                    } else {  // 逆向
                        // 从倒数第二个点开始
                        if (hook_pos.length > 1) {
                            hook_offset = hook_pos.length - 2;
                        } else {
                            hook_offset = 0;
                        }
                    }
                } else {
                    hook_status = -1;
                    // 设置当前坐标为默认挂机地点
                    battle_pCol = player.col;
                    battle_pRow = player.row;
                    printMessage(":当前地图：" + gameEnv.mapName + "不支持巡逻挂机！");
                }
            } else if (hook_status == 1) {  // 更新下一个巡逻挂机位置
                var data = hook_pos[hook_offset];
                // 这里检查第一个参数是否为负数，负数执行特别操作
                if (data[0] >= 0) {
                    if (data.length > 1) {
                        // 设置当前挂机位置
                        gameEnv.setHangupPos(data[0], data[1]);
                        // 前往该位置
                        player.setAimColRow(data[0], data[1]);
                        // 改变方向
                        if (data.length > 2) {
                            var value = parseInt(data[2]);
                            if (value == 0 || value == 1) {
                                hook_direction = value;
                            }
                        }
                        // 更新状态
                        hook_status = 2;
                        // 输出日志
                        printMessage(":开始前往第" + hook_offset + "个坐标：(" + data[0] + ", " + data[1] + ")");
                    }
                } else {
                    // 导航至功能代码
                    hook_status = 4;
                }
            } else if (hook_status == 2) {  // 寻径
                // 获取目标坐标位置
                var pos = hook_pos[hook_offset];
                // 判断是否到达目标位置
                if (pos[0] == player.col && pos[1] == player.row) {
                    // 如果攻击范围为0，直接到下一个点
                    if (GAME_VARS.attackScope <= 0) {
                        updateHookOffset();
                    } else {
                        // 更新挂机状态
                        printMessage(":抵达挂机点，开始执行挂机操作！");
                        // 直接原地挂机
                        battle_pCol = player.col;
                        battle_pRow = player.row;
                        hook_status = -1;
                    }
                } else if (!player.isAimColRow(pos[0], pos[1])) {
                    // 如果更改了寻径坐标，纠正
                    player.setAimColRow(pos[0], pos[1]);
                }
            } else if (hook_status == -1) {  // 定点挂机
                // 检测周围是否有可攻击敌人，没有前往下一个地点，这里必须放最后面
                if (gameEnv.status == 5) {
                    if (!GAME_VARS.isPatrol && hook_pos != null && gameEnv.getNearFightObj(GAME_VARS.attackScope) == null) {  // 巡逻挂机，并且附近没有可攻击单位
                        // 如果附近没有可攻击单位
                        updateHookOffset();
                        // 输出日志
                        printMessage(":当前位置怪物已清空，前往下一挂机点！");
                    } else {
                        battle();
                    }
                }
            } else if (hook_status == -2) {  // 定时定点挂机
                // 检测周围是否有可攻击敌人，没有前往下一个地点，这里必须放最后面
                if (gameEnv.status == 5) {
                    if (hook_hang_time > 0 || battle_status != 0) {
                        battle();
                    } else {
                        printMessage(":定时挂机结束！");
                        // 检测当前是否在恢复状态，是更新下一位置
                        updateHookOffset();
                    }
                }
            } else if (hook_status == 4) {  // 执行巡逻功能，执行完了才到下一个巡逻点
                var data = hook_pos[hook_offset];
                var sign = data[0];
                if (sign == -1) {  // 更新攻击范围
                    var value = data[1];
                    if (value >= 0) {
                        setNumberOptionGameVars("attackScope", value);
                    }
                    updateHookOffset();
                } else if (sign == -2) {  // 采集物品
                    if (hook_collection_status == 0) {  // 开始采集
                        // 获取该位置的采集物品
                        var obj = gameEnv.getNearCollectionObj();
                        // 开始采集该物品
                        if (obj != null && player.collectItem(obj)) {
                            printMessage(":采集物品中！");
                            hook_collection_status = 1;
                        } else {
                            printMessage(":采集失败，未找到采集对象，前往下个位置！");
                            updateHookOffset();
                        }
                    } else if (hook_collection_status == 1) {  // 等待中
                        // 采集完成
                        if (!gameEnv.isCollection) {
                            printMessage(":采集完成，前往下个位置！");
                            hook_collection_status = 0;
                            updateHookOffset();
                        }
                    }
                } else if (sign == -3) {  // -3是等待一段时间
                    if (hook_is_wait == 0) {  // 未等待
                        var value = parseInt(data[1]);
                        if (value > 0) {
                            printMessage(":巡逻当前等待时间：" + value + "秒。");
                            hook_is_wait = 1;
                            hook_wait_time = value;
                        } else {
                            printMessage(":巡逻等待时间参数错误！");
                            updateHookOffset();
                        }
                    } else if (hook_is_wait == 2) {  // 等待完成
                        printMessage(":巡逻等待结束。");
                        hook_is_wait = 0;
                        updateHookOffset();
                    }
                } else if (sign == -4) {  // -4进入挂机状态
                    // 设置挂机位置
                    battle_pCol = player.col;
                    battle_pRow = player.row;
                    // 如果有挂机时间，设置挂机时间
                    if (data.length > 1) {
                        hook_hang_time = parseInt(data[1]);
                        printMessage(":当前挂机剩余时间：" + hook_hang_time + "分钟！");
                        if (hook_hang_time > 0) {
                            // 设置进入定时挂机状态
                            hook_status = -2;
                        } else {
                            hook_hang_time = 0;
                            hook_status = -1;
                        }
                    } else {
                        printMessage(":当开始定点挂机！");
                        hook_status = -1;
                    }
                } else if (sign == -5) {    // 登出当前角色，并于一定时间后登入
                    hook_login_time = 0;
                    // 设置要选取的角色名字
                    hook_login_name = player.name;
                    if (data.length > 1) {
                        var value = data[1];
                        if (value >= 0) {
                            hook_login_time = value;
                        }
                    }
                    if (data.length > 2) {
                        hook_login_name = data[2];
                    }
                    // 重置autoplay
                    restAutoPlay();
                    // 重置战斗模块
                    restBattle();
                    // 退出到选角色界面
                    gameEnv.goRoleView();
                } else if (sign == -6) {    // 选取指定名称的游戏对象
                    if (data.length > 1) {
                        var r = player.selectNameObj(data[1]);
                        if (!r) {
                            printMessage(":未找到能选取的游戏对象！");
                        }
                    }
                    updateHookOffset();
                } else if (sign == -7) {    // 瞬移到指定位置
                    if (data.length > 2) {
                        var col = data[1];
                        var row = data[2];
                        if (col >= 0 && row >= 0) {
                            // 更新玩家当前位置
                            player.setObjPosition(col, row);
                        }
                    }
                    updateHookOffset();
                } else if (sign == -8) {    // 对当前选中目标释放技能
                    if (data.length > 1) {
                        // 获取当前要释放的技能
                        var skillName = data[1];
                        var index = getSkillMapIndex(skillName);
                        if (hook_skill_wait == 0) {
                            // 如果是正确的技能名称
                            if (index >= 0 && player.canCastSkill(index)) {
                                // 到释放技能
                                player.caskSkill(player.target, index);
                                hook_skill_wait = 2;
                            } else {
                                // 如果是等待技能释放完成
                                if (index >= 0 && data.length > 2 && parseInt(data[2]) == 1) {
                                    hook_skill_wait == 1;
                                    printMessage(":无法对当前目标使用技能：" + skillName + "，继续等待释放!");
                                } else {
                                    hook_skill_wait == 3;
                                    printMessage(":无法对当前目标使用技能：" + skillName + "，前往下个位置!");
                                }
                            }
                        } else if (hook_skill_wait == 1) {
                            // 一直等待放技能
                            if (player.canCastSkill(index)) {
                                // 对玩家当前选中目标释放技能
                                player.caskSkill(player.target, index);
                                hook_skill_wait = 2;
                            }
                        } else if (hook_skill_wait == 2) {
                            // 获取当前玩家状态，不是7或者8，就是施法完成
                            if (player.state != 7 && player.state != 8) {
                                hook_skill_wait = 3;
                            }
                        } else if (hook_skill_wait == 3) {
                            hook_skill_wait = 0;
                            updateHookOffset();
                        }
                    }
                } else {  // 不支持得默认跳过
                    updateHookOffset();
                }
            }
        }
    }
}

// 更新步进
function updateHookOffset() {
    hook_status = 1;
    if (hook_direction == 0) { // 正向
        hook_offset += 1;
    } else if (hook_direction == 1) {  // 逆向
        hook_offset -= 1;
    }
    // 处理边界
    if (hook_offset < 0) {  // 这个时候肯定是逆向了
        hook_offset = hook_pos.length - 1;
    } else if (hook_offset > hook_pos.length - 1) {  // 这里方向肯定是正向
        hook_offset = 0;
    }
}

// 输出信息到控制台
function printMessage(msg) {
    // 没有关闭日志输出
    if(GAME_VARS.isOpenLog){
        gameEnv.printMessage(7, msg);
    }
}

// 挂机函数 每一帧会执行
function hangUpFrame() {
    if (GAME_VARS.isHangUp) {
        // 检测当前挂机模式
        if(GAME_VARS.isTeamMode && player.isTeam){  // 如果是组队协作模式，并且有队伍
            teamBattle();
        }else{
            patrolBattle();
        }
    }
}

// 挂机函数 每一秒执行
function hangUpSecond() {
    if (GAME_VARS.isHangUp) {
        // 更新巡逻挂机等待时间
        if (hook_is_wait == 1) {
            hook_wait_time -= 1;
            if (hook_wait_time < 0) {
                hook_wait_time = 0;
                hook_is_wait = 2;
            }
        }
        // 更新等待队员时间
        if(hook_wait_team > 0){
            hook_wait_team -= 1;
        }
    }
}

// 挂机函数 每分钟执行
function hangUpMinute(){
    if(hook_status == -2 && hook_hang_time > 0){
        --hook_hang_time;
    }
}

// 重置autoplay
function restAutoPlay() {
    hook_status = 0;
    hook_pos = null;
    hook_offset = 0;
    hook_pos = null;
    hook_map_index = -1;
    hook_map_path = null;
    hook_map_path2 = null;
    hook_direction = 0;
    hook_is_wait = 0;
    hook_wait_time = 0;
    hook_hang_time = 0;
    hook_skill_wait = 0;
}

// 设置是否挂机
function setIsHangUp(value) {
    GAME_VARS.isHangUp = value;
    need_find_map = false;
    if (!value) {
        // 重置autoplay
        restAutoPlay();
        // 重置战斗模块
        restBattle();
    }
}
